#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script for updating UFW before.rules with OpenVPN client restrictions based on configuration in JSON format.
Author: Jan Zedník / dvestezar
Email: info@dvestezar.cz
"""

#  ----- definice promennych -----

__version__ = "1.0.0"
""" Verze skriptu """
__author__ = "Jan Zedník"
""" Autor skriptu """
__email__ = "info@dvestezar.cz"
""" Email autora skriptu """

config_name:str = "jb_ufw_vpn_cfg.js"
""" Jméno konfiguračního souboru s nastavením OpenVPN klientů pro UFW """

ufw_config_path:str = "/etc/ufw/"
""" Cesta k souboru UFW, který se má aktualizovat """

ufw_backup_dir:str = "backup_before_rules"
""" Adresář v `/etc/ufw/` pro zálohy předchozích verzí `before.rules` souboru."""

tun_interface:str = "tun+"
""" Název tunelového rozhraní, které se používá pro OpenVPN klienty. Pokud je  
- None, použije se výchozí rozhraní
- je zadáno "tun0", použije se pouze tun0, pokud "tun1", tak tun1
- "tun+" je pattern omezení takže automaticky omezí tunelová rozhraní začínající na "tun" následované libovolným číslem.
"""


#  ----- importy -----
import datetime,os,json,shutil,re,sys,ipaddress

# Rozšíření cesty k souboru s konfigurací
script_dir = os.path.dirname(os.path.realpath(sys.argv[0]))
config_name = os.path.join(script_dir, config_name)
""" Jméno konfiguračního souboru s nastavením OpenVPN klientů pro UFW (leží ve stejném adresáři jako tento script) """

#  ----- funkce -----

def valid_ban_to_date(banTo):
    try:
        dt = datetime.datetime.strptime(banTo, "%Y-%m-%d")
        return dt
    except Exception:
        return None

def addLine(lines: list, line: str, comment: str):
    """ Přidá řádek s komentářem do seznamu řádků
    
    Args:
        lines (list): Seznam řádků, do kterého se má přidat nový řádek.
        line (str): Řetězec, který se má přidat jako nový řádek.
        comment (str): Komentář, který se má přidat k novému řádku.
    """

    lines.append(line)
    if comment:
        lines.append(f"# {comment}")

def addGenerator(lines: list):
    """ Přidá informace o generátoru do seznamu řádků
    
    Args:
        lines (list): Seznam řádků, do kterého se má přidat informace o generátoru.
    """
    lines.append(f"# - Generated by {os.path.basename(sys.argv[0])} on {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append(f"# - Version: {__version__}")
    lines.append(f"# - Author: {__author__} <{__email__}>")
    lines.append("")

def addBoundary(lines:list, cfg: dict, bof:bool)->str:
    """ Vytvoří a vrátí hranici pro blok pravidel na základě konfigurace OpenVPN klientů
    
    Args:
        cfg (dict): Konfigurační slovník obsahující informace o serveru a klientech.
        bof (bool): Určuje, zda se má vytvořit začátek bloku (BOF) nebo konec bloku (EOF).
    Returns:
        str: Formátovaný řetězec s hranicí bloku.
    Raises:
        ValueError: Pokud konfigurace neobsahuje potřebné klíče.
    """
    if not bof:
        lines.append("")
    lines.append(f"# *** {'BOF' if bof else 'EOF'} OpenVPN JB Config - {cfg['server_name']} {cfg['server_ip'].rsplit('.',1)[0]}.0/{cfg['server_mask']}")
    if bof:
        lines.append("")

def getCreatedDate(c: dict) -> str:
    """ Získá datum vytvoření klienta z jeho konfigurace.
    
    Args:
        c (dict): Slovník obsahující informace o klientovi.
    Returns:
        str: Formátované datum vytvoření klienta.
    Raises:
        ValueError: Pokud datum vytvoření není platné nebo chybí.
    """
    created = c.get("created")
    if not created:
        return "Chybí datum vytvoření klienta"
    try:
        datetime.datetime.strptime(created, "%Y-%m-%d")
    except ValueError:
        try:
            datetime.datetime.strptime(created, "%Y-%m-%d %H:%M:%S")
        except ValueError:
            return "Chybný formát data vytvoření klienta"
    return created

def checkIPV4Address(ip: str) -> bool:
    """ Zkontroluje, zda je zadaný řetězec platnou IPv4 adresou.
    
    Args:
        ip (str): Řetězec obsahující IP adresu.
    Returns:
        bool: True, pokud je adresa platná, jinak False.
    Raises:
        ValueError: Pokud adresa není platná IPv4 adresa.
    """
    try:
        ipaddress.IPv4Address(ip)
        return True
    except ipaddress.AddressValueError:
        return False

def render_ufw_block(cfg: dict) -> str:
    """ Vytvoří blok pravidel pro UFW na základě konfigurace OpenVPN klientů 
    
    Args:
        cfg (dict): Konfigurační slovník obsahující informace o serveru a klientech.
    Returns:
        str: Formátovaný řetězec s pravidly pro UFW.
    Raises:
        ValueError: Pokud konfigurace neobsahuje potřebné klíče.        
    """
    
    # Kontrola IP serveru
    if not checkIPV4Address(cfg["server_ip"]):
        raise ValueError(f"Neplatná IP adresa serveru: {cfg['server_ip']}")
    
    lines = []
    addBoundary(lines, cfg, True)
    # přidáme kdy generováno a čím
    addGenerator(lines)
    
    server_ip = cfg["server_ip"]
    if tun_interface is None:
        tun = ""
    else:
        tun = f"-i {tun_interface} "

    ipList= [] # seznam IP adres klientů, které budou použity pro kontrolu duplicit
    for c in cfg["clients"]:
        comment = f"# --- {c['clientName']} ({c['clientIP']})"
        
        if checkIPV4Address(c["clientIP"]) :
            # Kontrola duplicitní IP adresy
            if c["clientIP"] in ipList:
                lines.append(comment + " - DUPLICATE IP, ignorováno")
            else:
                ipList.append(c["clientIP"])            
                comment += f" - vytvořeno {getCreatedDate(c)}"
                ruleComment= c.get("comment")
            
                if c["type"] == 1:
                    process_client_typ1(lines, c, server_ip, tun, comment, ruleComment)
                    
                elif c["type"] == 2:
                    process_client_typ2(lines, c, server_ip, tun, comment, ruleComment)
                    
                elif c["type"] == 0:
                    # vypnuto: žádná omezení
                    addLine(lines,comment + " - konfigurce clienta vypnuta, tzn. bez omezení", ruleComment)
                        
                else:
                    addLine(lines,comment + f" - neznámý typ {c['type']}, ignorováno", ruleComment)
                
        else:
            lines.append(comment + f" - neplatná IP adresa {c['clientIP']}, ignorováno")                
        
        lines.append("")
            
    addBoundary(lines, cfg, False)
    return "\n".join(lines)


def process_client_typ1(lines: list, c: dict, server_ip: str, tun: str, comment: str, ruleComment: str):
    """ Zpracuje klienta typu 1 (BAN) a přidá odpovídající pravidla do seznamu řádků.
    
    Args:
        lines (list): Seznam řádků, do kterého se mají přidat pravidla.
        c (dict): Slovník obsahující informace o klientovi.
        server_ip (str): IP adresa serveru.
        tun (str): Název tunelového rozhraní.
        comment (str): Komentář k pravidlu.
        ruleComment (str): Komentář k pravidlu pro UFW.
    
    Returns:
        None
    """
    banTo = c.get("banTo")
                        
    timeBan=False
    if banTo:
        dt = valid_ban_to_date(banTo)
        today = datetime.datetime.now()
        if dt:
            if dt >= today:
                ban_str = f"BAN do {banTo}"
                timeBan=True
            else:
                ban_str = f"BAN (vypršel {banTo})"
        else:
            ban_str = "BAN (Chyba v parametru datumu)"
    else:
        timeBan=True
        ban_str = "BAN (bez data)"
    
    addLine(lines,comment + f" - {ban_str}", ruleComment)
    if timeBan:
        # BAN: zakázat veškerý provoz
        lines.append(f'-A ufw-before-forward {tun}-s {c["clientIP"]} -m comment --comment "{c["clientName"]} - BAN" -j DROP')
        lines.append(f'-A ufw-before-input {tun}-s {c["clientIP"]} -m comment --comment "{c["clientName"]} - BAN" -j DROP')                    

def process_client_typ2(lines: list, c: dict, server_ip: str, tun: str, comment: str, ruleComment: str):
    """ Zpracuje klienta typu 2 (izolace) a přidá odpovídající pravidla do seznamu řádků.
    
    Args:
        lines (list): Seznam řádků, do kterého se mají přidat pravidla.
        c (dict): Slovník obsahující informace o klientovi.
        server_ip (str): IP adresa serveru.
        tun (str): Název tunelového rozhraní.
        comment (str): Komentář k pravidlu.
        ruleComment (str): Komentář k pravidlu pro UFW.
    Returns:
        None
    """
    # Izolace: povolit pouze přístup na serverovou IP
    addLine(lines,comment + " - izolace", ruleComment)
    lines.append(f'-A ufw-before-forward {tun}-s {c["clientIP"]} ! -d {server_ip} -m comment --comment "{c["clientName"]} - izolace" -j DROP')    


def load_json_from_jsfile(filename, bof_tag="// BOF JSON CFG"):
    """ Načte JSON blok z JavaScript souboru, který obsahuje BOF tag., EOF neobsahuje protože ani nemusí, na konci souboru je JSON zápis konfigurace
    
    Args:
        filename (str): Název souboru, ze kterého se má JSON blok načíst.
        bof_tag (str): Tag, který označuje začátek JSON bloku.
    Returns:
        dict: Načtený JSON blok jako slovník.
    Raises:
        FileNotFoundError: Pokud soubor neexistuje.
        json.JSONDecodeError: Pokud soubor obsahuje neplatný JSON.
        ValueError: Pokud BOF tag není nalezen v souboru.
    """
    
    with open(filename, "r", encoding="utf-8") as f:
        lines = f.readlines()
    # Najdi řádek s BOF tagem
    start = None
    for i, line in enumerate(lines):
        if bof_tag in line:
            start = i + 1
            break
    if start is None:
        raise ValueError(f"BOF tag '{bof_tag}' not found in file")
    json_block = "".join(lines[start:]).strip()
    return json.loads(json_block)

def loadConfig()-> dict:
    """ Načte a vrátí konfiguraci z JSON souboru
    
    Args:
        None
    Returns:
        dict: Načtená konfigurace jako slovník.
    Raises:
        FileNotFoundError: Pokud soubor neexistuje.
        json.JSONDecodeError: Pokud soubor obsahuje neplatný JSON.
    Raises:
        ValueError: Pokud soubor neobsahuje potřebné klíče.
    Raises:
        Exception: Pokud dojde k jiné chybě při načítání souboru.    
    """
    try:
        # Načti konfiguraci z JSON souboru
        cfg = load_json_from_jsfile(config_name)
    except FileNotFoundError:
        raise FileNotFoundError(f"Konfigurační soubor '{config_name}' nebyl nalezen.")
    except json.JSONDecodeError as e:
        raise json.JSONDecodeError(f"Chyba při načítání JSON z '{config_name}': {e.msg}", e.doc, e.pos)
    except Exception as e:
        raise Exception(f"Chyba při načítání konfigurace z '{config_name}': {e}")
    
    return cfg

def backupConfig()-> None:
    """ Vytvoří zálohu UFW pravidel před jejich úpravou.
    
    Args:
        None
    Returns:
        None
    """
    try:
        cfg_pth= os.path.join(ufw_config_path, "before.rules")
        
        now = datetime.datetime.now()
        bak_prefix = now.strftime("%Y-%m-%d-%H%M%S_")
        bak_path= os.path.join(ufw_config_path, ufw_backup_dir)
        if not os.path.exists(bak_path):
            os.makedirs(bak_path)
        # Záložní soubor bude v adresáři backup_before_rules    
        bak_path = os.path.join(bak_path, f"{bak_prefix}_before.rules.bak")
        shutil.copy2(cfg_pth, bak_path)    
        print(f"Záloha UFW pravidel byla vytvořena: {bak_path}")
    except Exception as e:
        raise Exception(f"Chyba při vytváření zálohy UFW pravidel: {e}")
        

def checkRoot():
    """ Zkontroluje, zda je skript spuštěn s právy roota.
    
    Args:
        None
    Raises:
        SystemExit: Pokud skript není spuštěn jako root.
    """
    if os.geteuid() != 0:
        raise SystemExit("Tento skript musí být spuštěn jako root.")


def injectBlock(content: str, block: str) -> str:
    """ Vloží blok pravidel do obsahu souboru.
    
    Args:
        content (str): Obsah souboru, do kterého se má blok vložit.
        block (str): Blok pravidel, který se má vložit.
    Returns:
        str: Aktualizovaný obsah souboru s vloženým blokem.
    """
    lines = content.splitlines()
    new_content = []
    inserted = False
    for i, line in enumerate(lines):
        new_content.append(line)
        if not inserted and line.strip() == "# End required lines":
            new_content.append("")  # prázdný řádek pro přehlednost
            new_content.append(block)
            inserted = True
    if not inserted:
        # Kdyby tam nedejbože "End required lines" nebyl, dáme na konec
        new_content.append("")
        new_content.append(block)
    return "\n".join(new_content)

def reloadUfw():
    """ Znovu načte UFW pravidla.
    
    Args:
        None
    Returns:
        None
    Raises:
        OSError: Pokud dojde k chybě při spouštění příkazu UFW.
    """
    try:
        os.system("ufw reload")
        print(" **** UFW pravidla byla úspěšně znovu načtena. ****")
    except OSError as e:
        raise OSError(f"Chyba při pokusu o znovunačtení UFW: {e}")

def modifyUfwRules():
    """ Hlavní funkce pro úpravu UFW pravidel.
    
    Args:
        None
    Returns:
        None
    Raises:
        ValueError: Pokud konfigurace neobsahuje potřebné klíče.
    """
    # Zkontroluje, zda je skript spuštěn s právy roota.
    checkRoot()

    cfg_path= os.path.join(ufw_config_path, "before.rules")

    # Ověření existence a práv pro UFW a konfig soubor
    if not os.path.exists(cfg_path):
        raise FileNotFoundError(f"Soubor '{cfg_path}' neexistuje.")
    if not os.access(cfg_path, os.W_OK):
        raise PermissionError(f"Nemáte oprávnění zapisovat do souboru '{cfg_path}'.")
    if not os.path.exists(config_name):
        raise FileNotFoundError(f"Konfigurační soubor '{config_name}' neexistuje.")
    if not os.access(config_name, os.R_OK):
        raise PermissionError(f"Nemáte oprávnění číst soubor '{config_name}'.")

    # config
    cfg = loadConfig()

    if not cfg:
        raise ValueError(f"Konfigurační soubor '{config_name}' je prázdný nebo neobsahuje potřebné klíče.")

    # Render blok pravidel pro UFW
    block = render_ufw_block(cfg)

    # otevřeme soubor s UFW pravidly a zkontrolujeme, zda blok již existuje
    with open(cfg_path, "r", encoding="utf-8") as f:
        content = f.read()

    bof_id = f"OpenVPN JB Config - {cfg['server_name']} {cfg['server_ip'].rsplit('.',1)[0]}.0/{cfg['server_mask']}"
    pattern = re.compile(rf"# \*\*\* BOF {re.escape(bof_id)}.*?# \*\*\* EOF {re.escape(bof_id)}", re.DOTALL)

    if pattern.search(content):
        # Blok existuje, nahradíme
        content = pattern.sub(block, content)
    else:
        # Blok neexistuje, najdeme místo po "# End required lines"
        content = injectBlock(content, block)

    # Na konci souboru je COMMMIT a pokud za ním není prázdný řádek tak UFW spadne, takže přidáme prázdný řádek
    if not content.endswith("\n"):
        content += "\n"
        
    # Vše připraveno pro zápis do souboru, takže ještě záloha
    backupConfig()

    with open(cfg_path, "w", encoding="utf-8") as f:
        f.write(content)
    
    print("Znovu načítám UFW pravidla...")
    reloadUfw()

# ----- hlavní část skriptu -----

print("Aktualizace UFW pravidel pro OpenVPN klienty...")

if __name__ == "__main__":
    try:
        modifyUfwRules()
    except Exception as e:
        print(f"Chyba při aktualizaci UFW pravidel: {e}")
        exit(1)

print("Hotovo.")